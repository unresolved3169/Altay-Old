<?php

/*
 *               _ _
 *         /\   | | |
 *        /  \  | | |_ __ _ _   _
 *       / /\ \ | | __/ _` | | | |
 *      / ____ \| | || (_| | |_| |
 *     /_/    \_|_|\__\__,_|\__, |
 *                           __/ |
 *                          |___/
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author TuranicTeam
 * @link https://github.com/TuranicTeam/Altay
 *
 */

declare(strict_types=1);

namespace pocketmine\network\mcpe\handler;

use pocketmine\math\Vector3;
use pocketmine\network\mcpe\protocol\AdventureSettingsPacket;
use pocketmine\network\mcpe\protocol\AnimatePacket;
use pocketmine\network\mcpe\protocol\BlockEntityDataPacket;
use pocketmine\network\mcpe\protocol\BlockPickRequestPacket;
use pocketmine\network\mcpe\protocol\BookEditPacket;
use pocketmine\network\mcpe\protocol\BossEventPacket;
use pocketmine\network\mcpe\protocol\ClientToServerHandshakePacket;
use pocketmine\network\mcpe\protocol\CommandBlockUpdatePacket;
use pocketmine\network\mcpe\protocol\CommandRequestPacket;
use pocketmine\network\mcpe\protocol\ContainerClosePacket;
use pocketmine\network\mcpe\protocol\CraftingEventPacket;
use pocketmine\network\mcpe\protocol\EntityEventPacket;
use pocketmine\network\mcpe\protocol\EntityFallPacket;
use pocketmine\network\mcpe\protocol\EntityPickRequestPacket;
use pocketmine\network\mcpe\protocol\InteractPacket;
use pocketmine\network\mcpe\protocol\InventoryTransactionPacket;
use pocketmine\network\mcpe\protocol\ItemFrameDropItemPacket;
use pocketmine\network\mcpe\protocol\LabTablePacket;
use pocketmine\network\mcpe\protocol\LevelSoundEventPacket;
use pocketmine\network\mcpe\protocol\MapInfoRequestPacket;
use pocketmine\network\mcpe\protocol\MobArmorEquipmentPacket;
use pocketmine\network\mcpe\protocol\MobEquipmentPacket;
use pocketmine\network\mcpe\protocol\ModalFormResponsePacket;
use pocketmine\network\mcpe\protocol\MovePlayerPacket;
use pocketmine\network\mcpe\protocol\PlayerActionPacket;
use pocketmine\network\mcpe\protocol\PlayerHotbarPacket;
use pocketmine\network\mcpe\protocol\PlayerInputPacket;
use pocketmine\network\mcpe\protocol\PlayerSkinPacket;
use pocketmine\network\mcpe\protocol\RequestChunkRadiusPacket;
use pocketmine\network\mcpe\protocol\ServerSettingsRequestPacket;
use pocketmine\network\mcpe\protocol\SetLocalPlayerAsInitializedPacket;
use pocketmine\network\mcpe\protocol\SetPlayerGameTypePacket;
use pocketmine\network\mcpe\protocol\ShowCreditsPacket;
use pocketmine\network\mcpe\protocol\SpawnExperienceOrbPacket;
use pocketmine\network\mcpe\protocol\SubClientLoginPacket;
use pocketmine\network\mcpe\protocol\TextPacket;
use pocketmine\Player;

/**
 * Temporary session handler implementation
 * TODO: split this up properly into different handlers
 */
class SimpleSessionHandler extends SessionHandler{

    /** @var Player */
    private $player;

    public function __construct(Player $player){
        $this->player = $player;
    }

    public function handleClientToServerHandshake(ClientToServerHandshakePacket $packet) : bool{
        return false; //TODO
    }

    public function handleText(TextPacket $packet) : bool{
        if($packet->type === TextPacket::TYPE_CHAT){
            return $this->player->chat($packet->message);
        }

        return false;
    }

    public function handleMovePlayer(MovePlayerPacket $packet) : bool{
        return $this->player->handleMovePlayer($packet);
    }

    public function handleLevelSoundEvent(LevelSoundEventPacket $packet) : bool{
        return $this->player->handleLevelSoundEvent($packet);
    }

    public function handleEntityEvent(EntityEventPacket $packet) : bool{
        return $this->player->handleEntityEvent($packet);
    }

    public function handleInventoryTransaction(InventoryTransactionPacket $packet) : bool{
        return $this->player->handleInventoryTransaction($packet);
    }

    public function handleMobEquipment(MobEquipmentPacket $packet) : bool{
        return $this->player->equipItem($packet->hotbarSlot);
    }

    public function handleMobArmorEquipment(MobArmorEquipmentPacket $packet) : bool{
        return true; //Not used
    }

    public function handleInteract(InteractPacket $packet) : bool{
        return $this->player->handleInteract($packet);
    }

    public function handleBlockPickRequest(BlockPickRequestPacket $packet) : bool{
        return $this->player->pickBlock(new Vector3($packet->blockX, $packet->blockY, $packet->blockZ), $packet->addUserData);
    }

    public function handleEntityPickRequest(EntityPickRequestPacket $packet) : bool{
        return false; //TODO
    }

    public function handlePlayerAction(PlayerActionPacket $packet) : bool{
        $pos = new Vector3($packet->x, $packet->y, $packet->z);

        switch($packet->action){
            case PlayerActionPacket::ACTION_START_BREAK:
                $this->player->startBreakBlock($pos, $packet->face);

                break;

            case PlayerActionPacket::ACTION_ABORT_BREAK:
            case PlayerActionPacket::ACTION_STOP_BREAK:
                $this->player->stopBreakBlock($pos);
                break;
            case PlayerActionPacket::ACTION_START_SLEEPING:
                //unused
                break;
            case PlayerActionPacket::ACTION_STOP_SLEEPING:
                $this->player->stopSleep();
                break;
            case PlayerActionPacket::ACTION_JUMP:
                $this->player->jump();
                return true;
            case PlayerActionPacket::ACTION_START_SPRINT:
                $this->player->toggleSprint(true);
                return true;
            case PlayerActionPacket::ACTION_STOP_SPRINT:
                $this->player->toggleSprint(false);
                return true;
            case PlayerActionPacket::ACTION_START_SNEAK:
                $this->player->toggleSneak(true);
                return true;
            case PlayerActionPacket::ACTION_STOP_SNEAK:
                $this->player->toggleSneak(false);
                return true;
            case PlayerActionPacket::ACTION_START_GLIDE:
                $this->player->toggleGlide(true);
                break;
            case PlayerActionPacket::ACTION_STOP_GLIDE:
                $this->player->toggleGlide(false);
                break;
            case PlayerActionPacket::ACTION_CONTINUE_BREAK:
                $this->player->continueBreakBlock($pos, $packet->face);
                break;
            case PlayerActionPacket::ACTION_SET_ENCHANTMENT_SEED:
                break; // TODO
            case PlayerActionPacket::ACTION_START_SWIMMING:
                if(!$this->player->isSwimming()){
                    $this->player->toggleSwimming(true);
                }
                break;
            case PlayerActionPacket::ACTION_STOP_SWIMMING:
                if($this->player->isSwimming()){ // for spam issue
                    $this->player->toggleSwimming(false);
                }
                break;
            default:
                $this->player->getServer()->getLogger()->debug("Unhandled/unknown player action type " . $packet->action . " from " . $this->player->getName());
                return false;
        }

        $this->player->setUsingItem(false);

        return true;
    }

    public function handleEntityFall(EntityFallPacket $packet) : bool{
        return true; //Not used
    }

    public function handleAnimate(AnimatePacket $packet) : bool{
        return $this->player->animate($packet->action);
    }

    public function handleContainerClose(ContainerClosePacket $packet) : bool{
        return $this->player->doCloseWindow($packet->windowId);
    }

    public function handlePlayerHotbar(PlayerHotbarPacket $packet) : bool{
        return true; //this packet is useless
    }

    public function handleCraftingEvent(CraftingEventPacket $packet) : bool{
        return true; //this is a broken useless packet, so we don't use it
    }

    public function handleAdventureSettings(AdventureSettingsPacket $packet) : bool{
        return $this->player->handleAdventureSettings($packet);
    }

    public function handleBlockEntityData(BlockEntityDataPacket $packet) : bool{
        return $this->player->handleBlockEntityData($packet);
    }

    public function handlePlayerInput(PlayerInputPacket $packet) : bool{
        if($this->player->isRiding()){
            $entity = $this->player->getRidingEntity();
            if($entity !== null and $entity->isAlive()){
                $entity->onRidingUpdate($this->player, $packet->motionX, $packet->motionY, $packet->jumping, $packet->sneaking);
            }
        }
        return true;
    }

    public function handleSetPlayerGameType(SetPlayerGameTypePacket $packet) : bool{
        if($packet->gamemode !== $this->player->getGamemode()){
            //Set this back to default. TODO: handle this properly
            $this->player->sendGamemode();
            $this->player->sendSettings();
        }
        return true;
    }

    public function handleSpawnExperienceOrb(SpawnExperienceOrbPacket $packet) : bool{
        return false; //TODO
    }

    public function handleMapInfoRequest(MapInfoRequestPacket $packet) : bool{
        return false; //TODO
    }

    public function handleRequestChunkRadius(RequestChunkRadiusPacket $packet) : bool{
        $this->player->setViewDistance($packet->radius);

        return true;
    }

    public function handleItemFrameDropItem(ItemFrameDropItemPacket $packet) : bool{
        return $this->player->handleItemFrameDropItem($packet);
    }

    public function handleBossEvent(BossEventPacket $packet) : bool{
        return false; //TODO
    }

    public function handleShowCredits(ShowCreditsPacket $packet) : bool{
        return false; //TODO: handle resume
    }

    public function handleCommandRequest(CommandRequestPacket $packet) : bool{
        return $this->player->handleCommandRequest($packet);
    }

    public function handleCommandBlockUpdate(CommandBlockUpdatePacket $packet) : bool{
        return false; //TODO
    }

    public function handlePlayerSkin(PlayerSkinPacket $packet) : bool{
        return $this->player->changeSkin($packet->skin, $packet->newSkinName, $packet->oldSkinName);
    }

    public function handleSubClientLogin(SubClientLoginPacket $packet) : bool{
        return false; //TODO
    }

    public function handleBookEdit(BookEditPacket $packet) : bool{
        return $this->player->handleBookEdit($packet);
    }

    public function handleModalFormResponse(ModalFormResponsePacket $packet) : bool{
        return $this->player->onFormSubmit($packet->formId, json_decode($packet->formData, true));
    }

    public function handleServerSettingsRequest(ServerSettingsRequestPacket $packet) : bool{
        $setting = $this->player->getServerSettingsForm();
        if($setting !== null){
            $this->player->sendServerSettings($setting);
        }

        return true;
    }

    public function handleLabTable(LabTablePacket $packet) : bool{
        return false; //TODO
    }

    public function handleSetLocalPlayerAsInitialized(SetLocalPlayerAsInitializedPacket $packet) : bool{
        return false; //TODO
    }
}